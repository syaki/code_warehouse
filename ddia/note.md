# Designing Data-Intensive Application

## 可靠性，可伸缩性，可维护性

理想情况下，批量作业的运行时间是数据集的大小除以吞吐量。

中位数也被称为第 50 百分位点，有时缩写为 p50。95、99 和 99.9 百分位点（缩写为 p95，p99 和 p999）。

由于服务器只能并行处理少量的事务（如受其 CPU 核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 头部阻塞（head-of-line blocking） 。

纵向伸缩（scaling up）（垂直伸缩（vertical scaling），转向更强大的机器）和横向伸缩（scaling out） （水平伸缩（horizontal scaling）
跨多台机器分配负载也称为“无共享（shared-nothing）”架构。

## 数据模型与查询语言

### 关系模型与文档模型

现在最著名的数据模型可能是 `SQL` 。它基于 `Edgar Codd` 在 1970 年提出的关系模型【1】：数据被组织成关系（ `SQL` 中称作表），其中每个关系是元组（ `SQL` 中称作行)的无序集合。

### `NoSQL`

不仅是 SQL（Not Only SQL）

混合持久化 `polyglot persistence`

模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch）

对象关系映射（ORM object-relational mapping） 框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异。

### 图数据模型

一个图由两种对象组成：顶点（`vertices`）（也称为节点（`nodes`） 或实体（`entities`）），和边（`edges`）（ 也称为关系（`relationships`）或弧 （`arcs`） ）。多种数据可以被建模为一个图形。

在属性图模型中，每个顶点（vertex） 包括：

唯一的标识符

-   一组 出边（outgoing edges）
-   一组 入边（ingoing edges）
-   一组属性（键值对）
-   每条 边（edge） 包括：

唯一标识符

-   边的起点/尾部顶点（tail vertex）
-   边的终点/头部顶点（head vertex）
-   描述两个顶点之间关系类型的标签
-   一组属性（键值对）

## 存储与检索

两大类存储引擎：日志结构（`log-structured`） 的存储引擎，以及面向页面（`page-oriented`） 的存储引擎（例如 B 树）。

### 驱动数据库的数据结构

```bash
#!/bin/bash
db_set () {
	echo "$1,$2" >> database
}

db_get () {
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

底层的存储格式非常简单：一个文本文件，每行包含一条逗号分隔的键值对（忽略转义问题的话，大致与`CSV`文件类似）。每次对 `db_set` 的调用都会向文件末尾追加记录，所以更新键的时候旧版本的值不会被覆盖 —— 因而查找最新值的时候，需要找到文件中键最后一次出现的位置（因此 `db_get` 中使用了 `tail -n 1` 。)

`db_set` 函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与 `db_set` 做的事情类似，许多数据库在内部使用了日志（`log`），也就是一个 仅追加（`append-only`） 的数据文件。

索引是从主数据衍生的附加（`additional`） 结构。许多数据库允许添加与删除索引，这不会影响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通常都会减慢写入速度，因为每次写入数据时都需要更新索引。

这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。

### 哈希索引

### `SSTables` 和 `LSM` 树

排序字符串表（`Sorted String Table`），简称 `SSTable` 。

键值对的序列按键排序。每个键只在每个合并的段文件中出现一次（压缩过程已经保证）。
